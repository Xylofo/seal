\documentclass[a4paper,titlepage]{article}

% Swedish support
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,swedish]{babel}

% Useful utilities
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{siunitx}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{mathtools}
%\usepackage{natbib}
\usepackage{algorithm} 
\usepackage{algpseudocode}

%\bibpunct{[}{]}{,}{n}{}{;}

\pgfplotsset{compat=1.10}

%====================  defined macros  ======================================

% \newcommand{\C}[1]{\Vert #1 \Vert}
\newcommand{\N}{\mathbb{N}}
\newcommand{\C}[1]{\mathfrak C \left( #1 \right)}
\renewcommand{\O}{\mathcal {O}}

%====================  style theorems  ======================================

\newtheorem{theorem}{Sats}
\newtheorem{lemma}{Lemma}
\newtheorem{conjecture}{Förmodan}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Korollarium}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{statement}{Påstående}
\newtheorem{problem}{Problem}
\newtheorem{fact}{Faktum}

\newcommand*\foobar{\includegraphics[height=2pt]{babyseal}}
%\catcode`\,=13 % make "." active
%\def,{\foobar}
\renewcommand\cdot{\,\raisebox{2pt}{\foobar}\,}
%====================  Document starts here  ======================================

\title{En studie av heltalens komplexitet}
\author{Lisa Vällfors \and Adrian Becedas \and Joakim Blikstad}

\begin{document}

\maketitle

\selectlanguage{english}
\begin{abstract}
    In this report we will study the complexity of N.
\end{abstract}
\selectlanguage{swedish}

\tableofcontents 
\newpage

\section{Inledning}

    \begin{definition}
       Vi benämner komplexiteten av ett positivt heltal $n$ som det minimala
       antalet $1$:or som krävs för att skriva $n$ med hjälp av addition,
       subtraktion och parenteser. Vi låter även $\C{n}$ beteckna komplexiteten av
       $n$. 
    \end{definition}

    \subsection{Bakgrund}

    \subsection{Frågeställningar}
        
        \begin{itemize}
            \item Finns det övre och undre gränser och hur tajta är dessa?
            \item Kan man få tajtare gränser för specifika tal, alternativt få
                en explicit formel?
                \begin{itemize}
                    \item kvadrater
                    \item primtal
                    \item 2 potenser
                    \item 3 potenser
                    \item andra potenser
                    \item triangeltal
                    \item fibonaccital
                \end{itemize}
            \item Hur kan man bäst generera talen, vad är bästa tidskomplexitet
                man kan uppnå?
            \item Hur fördelar sig $\frac{\C{n}}{\ln{n}}$?
            \item Kommer sekvensen ändras om man tillåter fler operationer
                utöver addition och multiplication?
                \begin{itemize}
                    \item subtraktion 
                    \item exponensiering
                \end{itemize}
        \end{itemize}


\section{Analys}

    \subsection{Övre gräns}

    I detta avsnitt presenterar vi den övre gränsen upptäckt av J. Arias de
    Reyna~\cite{spansk}.,
    \begin{definition}
        Vi definierar funktionen $A:\N\to\N$ på följande sätt:
        $$ A(n) = \left\{ \begin{matrix*}[l] 1 & \text{om } n=1 \\ 1+A(n-1) & \text{om $n$ är primtal} \\ \sum_{i=1}^kA(p_i) & \text{om } n=p_1p_2 \ldots p_k \end{matrix*} \right. $$
    \end{definition}

    Man ser att $A(n)\ge\C{n}$ då man alltid kan konstruera tal med
    funktionen~$A$. Värt att nämna är att det existerar $n$ där $A(n)\neq\C{n}$.
    Vi bevisar en övre gräns på $A(n)$ i syftet att få en övre gräns på $\C{n}$.

    \begin{lemma}
        $A(n)\le 3 \log_2{n}$ \quad för alla $n\ge2$
        \label{lemma:adrian}
    \end{lemma}
    \begin{proof}
        Vi utför stark induktion på $n$. Basfallet $n=2$ ger:
        \begin{align*}
            VL &=A(2)=1+A(1)=2\\
            HL &= 3 \log_2{2}=3 
        \end{align*}
        Alltså $VL \le HL$ som vi ville.
        Nu antar vi att \cref{lemma:adrian} gäller för alla $n \le k$. Vi vill
        visa att den även gäller för $n=k+1$.
        Vi har två fall, då $k+1$ är primtal och då det är sammansatt.

        $k+1$ är primtal ger enligt induktionsantagandet (notera $k$ är jämnt
        då $k+1$ är ett primtal $\ge3$):
        $$A(k+1) = 1 + A(k) = 1+2+A\left(\frac{k}{2}\right) \le 3 + 3 \log_2\frac{k}{2}$$
        Genom att använda identiteten \,$\log \frac{a}{b}=\log a -\log b$\, fås:
        $$ 3 + 3 \log_2\frac{k}{2} = 3 + 3\log_2 k - 3\log_2 2 = 3\log_2 k < 3\log_2 (k+1)$$
        Vilket ger att $A(k+1)\le 3\log_2 (k+1)$ om $k+1$ är ett primtal.

        Om $k+1$ är sammansatt kan vi skriva $k+1 = ab$ för heltal $a,b \ge 2$.
        Vi får då enligt induktionsantagandet:
        $$A(k+1) = A(a)+A(b) \le 3(\log_2a + \log_2b) = 3\log_2 ab = 3\log_2
        (k+1)$$ Alltså gäller även $A(k+1) \le 3\log_2 (k+1)$ om $k+1$ är
        sammansatt. Enligt induktionsprincipen är alltså \cref{lemma:adrian} nu
        bevisat.
    \end{proof}

    Beviset ger alltså att $\C{n}\le A(n)\le 3\log_2 n$ för alla $n\ge2$. Denna
    gräns är dock inte särskilt bra, men ingen bättre gräns har hittats.

    \subsection{Undre gräns}

    Att bevisa en stark undre gräns till $\C{n}$ är något svårare.
    Idén är att man låter $M_m$ vara det största heltalet som har komplexitet m.
    Detta betyder att $\C{M_m} = m$ och att för alla $k > M_m$ så är $\C{k}>m$.
    Med induktion kan man bevisa den slutna formeln (för $n>1$):
    $$ M_n = \left\{ \begin{matrix*}[l] 3^k & \text{om } n=3k \\
                             4\cdot3^{k-1} & \text{om } n=3k+1 \\
                                 2\cdot3^k & \text{om } n=3k+2 \end{matrix*}
            \right.$$
    Man låter då funktionen $B$ vara följande:
    $$ B(n) = \left\{ \begin{matrix*}[l] 3k & \text{om } n\in[3^k,4\cdot3^{k-1}) \\
                                       3k+1 & \text{om } n\in[4\cdot3^{k-1},2\cdot3^k) \\
                                       3k+2 & \text{om } n\in[2\cdot3^k,3^{k+1}) \end{matrix*}
            \right.$$
    Enligt ovanstående är $B(n)\le\C{n}$.
    \begin{lemma}
        $B(n)\ge 3\log_3 n$ \quad för alla $n\ge1$
    \end{lemma}
    \begin{proof}
       Om man falluppdelar för att $n$ ligger i respektive av de tre grupperna
       får man enkelt fram att lemmat gäller.
    \end{proof}


\section{Algoritmer för att generera sekvensen}

    http://arxiv.org/pdf/1404.2183v2.pdf

    För att generera data att undersöka, söks en algoritm för att beräkna
    komplexiteten av ett tal.

    \subsection{En enkel algoritm}

    För att lösa frågan börjar vi baklänges, och ställer oss frågan: vilken ska den
    sista operationen vara?  Det är ju givet att representationen antingen kommer
    kunna sammanfattas som $n = a\cdot b$ eller $n = a+b$.  Vi vill därför för både
    blabla rot, halv
    
    Vi ser i \ref{nn} att 

    \begin{algorithm}[H]
        \caption{$\O(N^N)$}
        \label{nn}
        \begin{algorithmic}[1]
            \Procedure{complexity}{$n$}\Comment{Returnerar komplexiteten av n}
                \If{$n = 1$}
                    \State \textbf{return} $1$
                \EndIf
                \State  $ans\gets \infty$
                \For{$i\gets 1, n/2$}
                    \State $ans\gets \min(ans, \textsc{complexity}(i)+\textsc{complexity}(n-i))$
                \EndFor
                \For{$i\gets 2, \sqrt{n}$}
                    \If{$n\mod i = 0$}
                        \State $ans\gets \min(ans, \textsc{complexity}(i)+\textsc{complexity}(n/i))$
                    \EndIf
                \EndFor
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}

    Denna algoritm finner utan problem komplexiteten av tal upp till runt 20.
    Därefter blir den alltför långsam.

    En insikt kan dock förbättra vår metod och tillåta beräkning av komplexiteten
    för tal upp till 10 000 på under en sekund.

    Problemet innehåller nämligen många överlappande delproblem, och dessa löser
    algoritmen ett flertal gånger. Om vi istället sparar resultatet för varje tal
    kan de återanvändas. Vi ändrar nu även vår metod från att vara rekursiv, till
    att vara iterativ.


    \begin{algorithm}[H]
        \caption{$\O(N^2)$}
        \begin{algorithmic}[1]
            \Procedure{complexity}{$n$}\Comment{Returnerar komplexiteten av n}
                \State Deklarera $v$
                \For{$i\gets 1, n$}
                    \State \textbf{return} $1$
                    \State  $ans\gets \infty$
                    \For{$j\gets 1, n/2$}
                        \State $ans\gets \min(ans, v[i]+ v[n-i])$
                    \EndFor
                    \For{$i\gets 2, \sqrt{n}$}
                        \If{$n\mod i = 0$}
                            \State $ans\gets \min(ans, v[i]+v[n/i])$
                        \EndIf
                    \EndFor
                    \State $v[i] \gets ans$
                \EndFor
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}


    Att algoritmen nu är ickerekursiv gör ingen skillnad i tidskomplexitet, men gör
    den i praktiken snabbare samt gör den något enklare att analysera.

    Denna procedur har en loop med två loopar inuti. Detta gör att en beräkning av
    $\C{n}$ tar $n\left(\frac{n}{2}+\sqrt n\right) = \frac{n^2}{2} + n\sqrt n$.
    Eftersom vi räknar asymptotiskt spelar varken långsammare växande termer eller
    konstantfaktorer roll,  vilket innebär att algoritmen får tidskomplexiteten
    $\O(n^2)$

\newpage
\begin{thebibliography}{9}

    \bibitem{spansk}
        \text{J. Arias de Reyna}, \emph{Complejidad de los n'umeros naturales}, 2000

\end{thebibliography}
%\bibliography{bib}{}
%\bibliographystyle{unsrtnat}

\end{document}

